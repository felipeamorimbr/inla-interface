a <- matrix(1:4, nrow = 2)
str(a[1, ])
a
a[1, ]
str(a[1, ])
str(a[1, , drop = FALSE])
a[1, , drop = FALSE]
##-- Data.frames
df <- data.frame(a = 1:2, b = 1:2)
str(df[, "a"])
str(df[, "a", drop = FALSE])
##-- Factors
z <- factor(c("a", "b"))
z[1]
z[1, drop = TRUE]
mtcars[mtcars$cyl = 4, ]
mtcars[mtcars$cyl == 4, ]
mtcars[-c(1:4), ]         # mtcars[-1:4, ]
mtcars[mtcars$cyl <= 5, ] # mtcars[mtcars$cyl <= 5]
mtcars[mtcars$cyl == 4 | mtcars$cyl  == 6, ]
##----------------- 2) Why does the following code yield five missing values? (Hint: why is it different from x[NA_real_]?)
x <- 1:5
x[NA]
##----------------- 2) Why does the following code yield five missing values? (Hint: why is it different from x[NA_real_]?)
x <- 1:5
x[NA]
x[NA_real_]
x
x[1]
x[NA]
x[T]
x[F]
##----------------- 3) What does upper.tri() return? How does subsetting a matrix with it work? Do we need any additional
##-- subsetting rules to describe its behaviour?
x <- outer(1:5, 1:5, FUN = "*")
x
upper.tri(x)
##----------------- 4) Why does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?
mtcars[1:20]
##----------------- 4) Why does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?
mtcars[1:2]
##----------------- 5)  Implement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x)
##-- where x is a matrix).
get_diag <- function(mat){
dim_min <- min(nrow(mat), ncol(mat))
pos <- cbind(1:dim_min, 1:dim_min)
mat[pos]
}
get_diag(matrix(1:20, ncol = 4))
matrix(1:20, ncol = 4)
is.na(df)
df
is.na(df)
is.na(df)
df
is.na(df)
df[is.na(df)]
df[is.na(df)] <- 0
df
##-- + Section 4.2) Selecting a single element ----
##-- + Section 4.3.1) [[
x <- list(1:3, "a", 4:6)
x[c(1,2)]
x[[c(1,2)]]
k <- x[[c(1,2)]]
k
x[[c(1, 2)]] == x[[1]][[2]]
##-- + Section 4.3.1) $
x <- list(abc = 1)
x$a
x[["a"]]
options(warnPartialMatchDollar = TRUE)
x$a
##-- + Section 4.3.3) Missing and out-of-bounds indices
x <- list(
a = list(1, 2, 3),
b = list(3, 4, 5)
)
purrr::pluck(x, "a", 1)
purrr::pluck(x, "c", 1)
purrr::pluck(x, "c", 1, .default = NA)
cyl
mtcars
head(mtcars)
##-- + Section 4.3.4) @ and slot() ----
##-- Ok
##-- + Section 4.3.5) Exercises ----
##----------------- 1) Brainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.
mtcars[3]
mtcars[,3]
mtcars["cyl"]
##-- + Section 4.3.4) @ and slot() ----
##-- Ok
##-- + Section 4.3.5) Exercises ----
##----------------- 1) Brainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.
mtcars[1, 3]
mtcars[,3][1]
mtcars[1,"cyl"]
head(mtcars)
##-- + Section 4.3.4) @ and slot() ----
##-- Ok
##-- + Section 4.3.5) Exercises ----
##----------------- 1) Brainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.
mtcars[1, 2]
mtcars[,2][1]
mtcars[1,"cyl"]
mtcars$"cyl"[3]
mtcars$"cyl"
##-- + Section 4.3.4) @ and slot() ----
##-- Ok
##-- + Section 4.3.5) Exercises ----
##----------------- 1) Brainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.
mtcars[3, 2]
mtcars[, 2][3]
mtcars[3,"cyl"]
mtcars$"cyl"[3]
mtcars[c(3,2)]
mtcars[[c(3,2)]]
mtcars[[c(2,3)]]
##----------------- 2) Given a linear model, e.g., mod <- lm(mpg ~ wt, data = mtcars), extract the residual degrees of freedom.
##-- Then extract the R squared from the model summary (summary(mod))
mod <- lm(mpg ~ wt, data = mtcars)
mod$df.residual
mod[["df.residual"]]
sum_mod <- summary(mod)
sum_mod[["r.squared"]]
##-- + Section 4.4) Subsetting and assignment ----
##-- With lists, you can use x[[i]] <- NULL to remove a component. To add a literal NULL, use x[i] <- list(NULL):
mtcars[] <- lapply(mtcars, as.integer)
lapply(mtcars, as.integer)
##-- + Section 4.4) Subsetting and assignment ----
##-- With lists, you can use x[[i]] <- NULL to remove a component. To add a literal NULL, use x[i] <- list(NULL):
mtcars[] <- lapply(mtcars, as.integer)
is.data.frame(mtcars)
mtcars <- lapply(mtcars, as.integer)
is.data.frame(mtcars)
##-- + Section 4.5) Applications ----
##-- + Section 4.5.1) Lookup tables (character subsetting) ----
x <- c("m", "f", "u", "f", "f", "m", "m")
x
lookup <- c(m = "Male", f = "Female", u = NA)
lookup
lookup[x]
unname(lookup[x])
##-- + Section 4.5.2) Matching and merging by hand (integer subsetting) ----
grades <- c(1, 2, 2, 3, 1)
info <- data.frame(
grade = 3:1,
desc = c("Excellent", "Good", "Poor"),
fail = c(F, F, T)
)
info
id <- match(grades, info$grade)
id
id
info[id,]
##-- + Section 4.5.3) Random samples and bootstraps (integer subsetting) ----
df <- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])
# Randomly reorder
df[sample(nrow(df)), ]
# Select 3 random rows
df[sample(nrow(df), 3), ]
# Select 6 bootstrap replicates
df[sample(nrow(df), 6, replace = TRUE), ]
##-- + Section 4.5.4) Ordering (integer subsetting) ----
x <- c("b", "c", "a")
order(x)
x[order(x)]
# Randomly reorder df
df2 <- df[sample(nrow(df)), 3:1]
df2
df2[order(df2$x), ]
df2[, order(names(df2))]
##-- + Section 4.5.5) Expanding aggregated counts (integer subsetting) ----
df <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))
rep(1:nrow(df), df$n)
df[rep(1:nrow(df), df$n), ]
##-- + Section 4.5.6) Removing columns from data frames (character ) ----
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df$z <- NULL
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df[c("x", "y")]
df[setdiff(names(df), "z")]
##-- + Section 4.5.7) Selecting rows based on a condition (logical subsetting) ----
mtcars[mtcars$gear == 5, ]
##-- + Section 4.5.7) Selecting rows based on a condition (logical subsetting) ----
mtcars[mtcars$gear == 5, ]
mtcars$gear
mtcars$gear == 5
##-- + Section 4.5.7) Selecting rows based on a condition (logical subsetting) ----
mtcars[mtcars$gear == 5, ]
mtcars
mtcars[] <- mtcars
mtcars
as.data.frame(mtcars)
mtcars <- as.data.frame(mtcars)
##-- + Section 4.5.7) Selecting rows based on a condition (logical subsetting) ----
mtcars[mtcars$gear == 5, ]
mtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]
##-- + Section 4.5.8) Boolean algebra versus sets (logical and integer) ----
x <- sample(10) < 4
which(x)
unwhich <- function(x, n) {
out <- rep_len(FALSE, n)
out[x] <- TRUE
out
}
unwhich(which(x), 10)
(x1 <- 1:10 %% 2 == 0)
(x2 <- which(x1))
(y1 <- 1:10 %% 5 == 0)
(y2 <- which(y1))
# X & Y <-> intersect(x, y)
x1 & y1
#>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
intersect(x2, y2)
# X | Y <-> union(x, y)
x1 | y1
union(x2, y2)
# X & !Y <-> setdiff(x, y)
x1 & !y1
setdiff(x2, y2)
# xor(X, Y) <-> setdiff(union(x, y), intersect(x, y))
xor(x1, y1)
setdiff(union(x2, y2), intersect(x2, y2))
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
df <- data.frame(a = 1:10, b = 2:11, c = 3:12)
df
cbind(sample(1:10, size = 10), sample(1:3, size = 3))
sample(1:10, size = 10)
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(10*p), ncol = p))
df
df[cbind(sample(1:10, size = 10), rep(sample(1:3, size = 3)), each = 10)]
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
df[cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p)), each = n)]
cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p)), each = n)
dim(cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p)), each = n))
df[[cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p)), each = n)]]
cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p)), each = n)
class(cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p)), each = n))
rep(sample(1:n, size = n), each = p)
rep(sample(1:p, size = p)), each = n)
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
df[cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p), each = n))]
cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p), each = n))
sample(1:n, size = n)
rep(sample(1:n, size = n), each = p)
cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p), each = n))
rep(sample(1:n, size = n), each = p)
length(rep(sample(1:n, size = n), each = p))
length(rep(sample(1:p, size = p), each = n))
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
df
rep(sample(1:n, size = n)
, each = p)
cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p), each = n))
df[cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p), each = n))]
df[[cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p), each = n))]]
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
df[cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p), each = n))]
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
df[cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p), each = n)), drop = FALSE]
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
df[cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p), each = n)), drop = TRUE]
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
df
cbind(rep(sample(1:n, size = n), each = p),
rep(sample(1:p, size = p), each = n))
sample(size = n)
cbind(sample(size = n),
sample(size = p))
sample(n)
sample(n)
df[sample(n), sample(p)]
sample(p)
sample(p)
sample(p)
df[sample(n), sample(p)]
df[sample(n), sample(p), drop = FALSE]
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
df
df[sample(n), sample(p), drop = FALSE]
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
row <- sample(n)
col <- sample(p)
df[row, col, drop = FALSE]
row
col
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
row <- sample(n)
col <- sample(p)
df
row
col
df[row, col, drop = FALSE]
##-- x[-which(y)] is not equivalent to x[!y]
##-- + Section 4.5.9) Exercises ----
##----------------- 1) How would you randomly permute the columns of a data frame? (This is an important technique in random forests.)
##-- Can you simultaneously permute the rows and columns in one step?
n <- 10
p <- 3
df <- data.frame(matrix(rnorm(n*p), ncol = p))
row <- sample(n)
col <- sample(p)
row
col
##----------------- 3) How could you put the columns in a data frame in alphabetical order?
iris[order(names(iris))]
##----------------- 2) How would you select a random sample of m rows from a data frame? What if the sample had to be contiguous
##-- (i.e., with an initial row, a final row, and every row in between)?
m <- 10
iris[sample(nrow(iris), m), , drop = FALSE]
start <- sample(nrow(iris) - m + 1, 1)
start
end <- start + m - 1
end
iris[start:end, , drop = FALSE]
log(150)/64
exp(log(150)2)
exp(log(150)*2)
exp(log(150)*128/64)
22500/60
(22500/60)/60
install_github("rpremraj/mailR")
devtools::install_github("rpremraj/mailR")
install.packages("rJava")
install.packages("rJava")
##-- Packages ----
devtools::install_github("rpremraj/mailR")
library(mailR)
library(mailR)
library(mailR)
email <- send.mail(from = "Douglas Azevedo <douglasrm.azevedo@gmail.com>",
to = "larissa.sayuri.fcs@gmail.com",
subject = "E-mail do R",
body = "Este e-mail foi enviado do R. Sintaxe: \n
devtools::install_github('rpremraj/mailR') \n
library(mailR) \n
email <- send.mail(from = 'Douglas Azevedo <douglasrm.azevedo@gmail.com>', \n
to = 'larissa.sayuri.fcs@gmail.com', \n
subject = 'E-mail do R', \n
body = 'Este e-mail foi enviado do R. Sintaxe:', \n
encoding = 'utf-8', \n
smtp = list(host.name = 'smtp.gmail.com', port = 465,
user.name = 'douglasrm.azevedo',
passwd = 'minhasenha', ssl = T),
authenticate = TRUE,
send = TRUE)",
encoding = "utf-8",
smtp = list(host.name = "smtp.gmail.com", port = 465, user.name = "douglasrm.azevedo", passwd = "99algumacoisa", ssl = T),
authenticate = TRUE,
send = TRUE)
email <- send.mail(from = "Douglas Azevedo <douglasrm.azevedo@gmail.com>",
to = "larissa.sayuri.fcs@gmail.com",
subject = "E-mail do R",
body = "Este e-mail foi enviado do R. Sintaxe:",
encoding = "utf-8",
smtp = list(host.name = "smtp.gmail.com", port = 465, user.name = "douglasrm.azevedo", passwd = "99algumacoisa", ssl = T),
authenticate = TRUE,
send = TRUE)
(3^4)*(2^4)
((3*2)^4)
install.packages("tabulizer")
#Global
library(shiny)
library(shinyMenus)
library(shinyjs)
library(INLA)
library(rhandsontable)
library(shinyWidgets)
install.packages("rhandsontable")
devtools::install_github("ebailey78/shinyMenus")
runApp('Documents/git/github/felipe/inla-interface/novo inla interface')
setwd("~/Documents/git/github/felipe/inla-interface/novo inla interface")
runApp()
actionLink
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?shinyjs::hidden
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?dataTableOutput
runApp()
runApp()
runApp()
runApp()
which(sapply(indata, class) == "numeric")
indata %>%
DT::formatRound(columns = cols, digits = 4)
%>%
DT::formatRound(table = indata, columns = cols, digits = 4)
class(indata)
cols
DT::formatRound(table = indata, columns = 1:3, digits = 4)
indata
?formatRound
DT::formatRound(table = datatable(indata), columns = 1:3, digits = 4)
DT::formatRound(table = DT::datatable(indata), columns = 1:3, digits = 4)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
DT::renderDT
?DT::renderDT
?renderDataTable
runApp()
